/*
 * stash-server
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1AzureDiskVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1AzureFileVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1CephFSVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1CinderVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1ConfigMapVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1DownwardAPIVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1EmptyDirVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1FCVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1FlexVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1FlockerVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1GCEPersistentDiskVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1GitRepoVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1GlusterfsVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1HostPathVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1ISCSIVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1NFSVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeClaimVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1PhotonPersistentDiskVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1PortworxVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1ProjectedVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1QuobyteVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1RBDVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1ScaleIOVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1SecretVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1StorageOSVolumeSource;
import io.swagger.client.model.IoK8sApiCoreV1VsphereVirtualDiskVolumeSource;
import java.io.IOException;

/**
 * ComGithubAppscodeStashApisStashV1alpha1LocalSpec
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-04-09T00:59:16.508-07:00")
public class ComGithubAppscodeStashApisStashV1alpha1LocalSpec {
  @SerializedName("awsElasticBlockStore")
  private IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore = null;

  @SerializedName("azureDisk")
  private IoK8sApiCoreV1AzureDiskVolumeSource azureDisk = null;

  @SerializedName("azureFile")
  private IoK8sApiCoreV1AzureFileVolumeSource azureFile = null;

  @SerializedName("cephfs")
  private IoK8sApiCoreV1CephFSVolumeSource cephfs = null;

  @SerializedName("cinder")
  private IoK8sApiCoreV1CinderVolumeSource cinder = null;

  @SerializedName("configMap")
  private IoK8sApiCoreV1ConfigMapVolumeSource configMap = null;

  @SerializedName("downwardAPI")
  private IoK8sApiCoreV1DownwardAPIVolumeSource downwardAPI = null;

  @SerializedName("emptyDir")
  private IoK8sApiCoreV1EmptyDirVolumeSource emptyDir = null;

  @SerializedName("fc")
  private IoK8sApiCoreV1FCVolumeSource fc = null;

  @SerializedName("flexVolume")
  private IoK8sApiCoreV1FlexVolumeSource flexVolume = null;

  @SerializedName("flocker")
  private IoK8sApiCoreV1FlockerVolumeSource flocker = null;

  @SerializedName("gcePersistentDisk")
  private IoK8sApiCoreV1GCEPersistentDiskVolumeSource gcePersistentDisk = null;

  @SerializedName("gitRepo")
  private IoK8sApiCoreV1GitRepoVolumeSource gitRepo = null;

  @SerializedName("glusterfs")
  private IoK8sApiCoreV1GlusterfsVolumeSource glusterfs = null;

  @SerializedName("hostPath")
  private IoK8sApiCoreV1HostPathVolumeSource hostPath = null;

  @SerializedName("iscsi")
  private IoK8sApiCoreV1ISCSIVolumeSource iscsi = null;

  @SerializedName("mountPath")
  private String mountPath = null;

  @SerializedName("nfs")
  private IoK8sApiCoreV1NFSVolumeSource nfs = null;

  @SerializedName("persistentVolumeClaim")
  private IoK8sApiCoreV1PersistentVolumeClaimVolumeSource persistentVolumeClaim = null;

  @SerializedName("photonPersistentDisk")
  private IoK8sApiCoreV1PhotonPersistentDiskVolumeSource photonPersistentDisk = null;

  @SerializedName("portworxVolume")
  private IoK8sApiCoreV1PortworxVolumeSource portworxVolume = null;

  @SerializedName("projected")
  private IoK8sApiCoreV1ProjectedVolumeSource projected = null;

  @SerializedName("quobyte")
  private IoK8sApiCoreV1QuobyteVolumeSource quobyte = null;

  @SerializedName("rbd")
  private IoK8sApiCoreV1RBDVolumeSource rbd = null;

  @SerializedName("scaleIO")
  private IoK8sApiCoreV1ScaleIOVolumeSource scaleIO = null;

  @SerializedName("secret")
  private IoK8sApiCoreV1SecretVolumeSource secret = null;

  @SerializedName("storageos")
  private IoK8sApiCoreV1StorageOSVolumeSource storageos = null;

  @SerializedName("subPath")
  private String subPath = null;

  @SerializedName("vsphereVolume")
  private IoK8sApiCoreV1VsphereVirtualDiskVolumeSource vsphereVolume = null;

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec awsElasticBlockStore(IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
    return this;
  }

   /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * @return awsElasticBlockStore
  **/
  @ApiModelProperty(value = "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore")
  public IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource getAwsElasticBlockStore() {
    return awsElasticBlockStore;
  }

  public void setAwsElasticBlockStore(IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec azureDisk(IoK8sApiCoreV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
    return this;
  }

   /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * @return azureDisk
  **/
  @ApiModelProperty(value = "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.")
  public IoK8sApiCoreV1AzureDiskVolumeSource getAzureDisk() {
    return azureDisk;
  }

  public void setAzureDisk(IoK8sApiCoreV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec azureFile(IoK8sApiCoreV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
    return this;
  }

   /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * @return azureFile
  **/
  @ApiModelProperty(value = "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.")
  public IoK8sApiCoreV1AzureFileVolumeSource getAzureFile() {
    return azureFile;
  }

  public void setAzureFile(IoK8sApiCoreV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec cephfs(IoK8sApiCoreV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
    return this;
  }

   /**
   * CephFS represents a Ceph FS mount on the host that shares a pod&#39;s lifetime
   * @return cephfs
  **/
  @ApiModelProperty(value = "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime")
  public IoK8sApiCoreV1CephFSVolumeSource getCephfs() {
    return cephfs;
  }

  public void setCephfs(IoK8sApiCoreV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec cinder(IoK8sApiCoreV1CinderVolumeSource cinder) {
    this.cinder = cinder;
    return this;
  }

   /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @return cinder
  **/
  @ApiModelProperty(value = "Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md")
  public IoK8sApiCoreV1CinderVolumeSource getCinder() {
    return cinder;
  }

  public void setCinder(IoK8sApiCoreV1CinderVolumeSource cinder) {
    this.cinder = cinder;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec configMap(IoK8sApiCoreV1ConfigMapVolumeSource configMap) {
    this.configMap = configMap;
    return this;
  }

   /**
   * ConfigMap represents a configMap that should populate this volume
   * @return configMap
  **/
  @ApiModelProperty(value = "ConfigMap represents a configMap that should populate this volume")
  public IoK8sApiCoreV1ConfigMapVolumeSource getConfigMap() {
    return configMap;
  }

  public void setConfigMap(IoK8sApiCoreV1ConfigMapVolumeSource configMap) {
    this.configMap = configMap;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec downwardAPI(IoK8sApiCoreV1DownwardAPIVolumeSource downwardAPI) {
    this.downwardAPI = downwardAPI;
    return this;
  }

   /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   * @return downwardAPI
  **/
  @ApiModelProperty(value = "DownwardAPI represents downward API about the pod that should populate this volume")
  public IoK8sApiCoreV1DownwardAPIVolumeSource getDownwardAPI() {
    return downwardAPI;
  }

  public void setDownwardAPI(IoK8sApiCoreV1DownwardAPIVolumeSource downwardAPI) {
    this.downwardAPI = downwardAPI;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec emptyDir(IoK8sApiCoreV1EmptyDirVolumeSource emptyDir) {
    this.emptyDir = emptyDir;
    return this;
  }

   /**
   * EmptyDir represents a temporary directory that shares a pod&#39;s lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * @return emptyDir
  **/
  @ApiModelProperty(value = "EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir")
  public IoK8sApiCoreV1EmptyDirVolumeSource getEmptyDir() {
    return emptyDir;
  }

  public void setEmptyDir(IoK8sApiCoreV1EmptyDirVolumeSource emptyDir) {
    this.emptyDir = emptyDir;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec fc(IoK8sApiCoreV1FCVolumeSource fc) {
    this.fc = fc;
    return this;
  }

   /**
   * FC represents a Fibre Channel resource that is attached to a kubelet&#39;s host machine and then exposed to the pod.
   * @return fc
  **/
  @ApiModelProperty(value = "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.")
  public IoK8sApiCoreV1FCVolumeSource getFc() {
    return fc;
  }

  public void setFc(IoK8sApiCoreV1FCVolumeSource fc) {
    this.fc = fc;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec flexVolume(IoK8sApiCoreV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
    return this;
  }

   /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   * @return flexVolume
  **/
  @ApiModelProperty(value = "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.")
  public IoK8sApiCoreV1FlexVolumeSource getFlexVolume() {
    return flexVolume;
  }

  public void setFlexVolume(IoK8sApiCoreV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec flocker(IoK8sApiCoreV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
    return this;
  }

   /**
   * Flocker represents a Flocker volume attached to a kubelet&#39;s host machine. This depends on the Flocker control service being running
   * @return flocker
  **/
  @ApiModelProperty(value = "Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running")
  public IoK8sApiCoreV1FlockerVolumeSource getFlocker() {
    return flocker;
  }

  public void setFlocker(IoK8sApiCoreV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec gcePersistentDisk(IoK8sApiCoreV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
    return this;
  }

   /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @return gcePersistentDisk
  **/
  @ApiModelProperty(value = "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk")
  public IoK8sApiCoreV1GCEPersistentDiskVolumeSource getGcePersistentDisk() {
    return gcePersistentDisk;
  }

  public void setGcePersistentDisk(IoK8sApiCoreV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec gitRepo(IoK8sApiCoreV1GitRepoVolumeSource gitRepo) {
    this.gitRepo = gitRepo;
    return this;
  }

   /**
   * GitRepo represents a git repository at a particular revision.
   * @return gitRepo
  **/
  @ApiModelProperty(value = "GitRepo represents a git repository at a particular revision.")
  public IoK8sApiCoreV1GitRepoVolumeSource getGitRepo() {
    return gitRepo;
  }

  public void setGitRepo(IoK8sApiCoreV1GitRepoVolumeSource gitRepo) {
    this.gitRepo = gitRepo;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec glusterfs(IoK8sApiCoreV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
    return this;
  }

   /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
   * @return glusterfs
  **/
  @ApiModelProperty(value = "Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md")
  public IoK8sApiCoreV1GlusterfsVolumeSource getGlusterfs() {
    return glusterfs;
  }

  public void setGlusterfs(IoK8sApiCoreV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec hostPath(IoK8sApiCoreV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
    return this;
  }

   /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @return hostPath
  **/
  @ApiModelProperty(value = "HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath")
  public IoK8sApiCoreV1HostPathVolumeSource getHostPath() {
    return hostPath;
  }

  public void setHostPath(IoK8sApiCoreV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec iscsi(IoK8sApiCoreV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
    return this;
  }

   /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md
   * @return iscsi
  **/
  @ApiModelProperty(value = "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md")
  public IoK8sApiCoreV1ISCSIVolumeSource getIscsi() {
    return iscsi;
  }

  public void setIscsi(IoK8sApiCoreV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec mountPath(String mountPath) {
    this.mountPath = mountPath;
    return this;
  }

   /**
   * Get mountPath
   * @return mountPath
  **/
  @ApiModelProperty(value = "")
  public String getMountPath() {
    return mountPath;
  }

  public void setMountPath(String mountPath) {
    this.mountPath = mountPath;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec nfs(IoK8sApiCoreV1NFSVolumeSource nfs) {
    this.nfs = nfs;
    return this;
  }

   /**
   * NFS represents an NFS mount on the host that shares a pod&#39;s lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @return nfs
  **/
  @ApiModelProperty(value = "NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs")
  public IoK8sApiCoreV1NFSVolumeSource getNfs() {
    return nfs;
  }

  public void setNfs(IoK8sApiCoreV1NFSVolumeSource nfs) {
    this.nfs = nfs;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec persistentVolumeClaim(IoK8sApiCoreV1PersistentVolumeClaimVolumeSource persistentVolumeClaim) {
    this.persistentVolumeClaim = persistentVolumeClaim;
    return this;
  }

   /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * @return persistentVolumeClaim
  **/
  @ApiModelProperty(value = "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims")
  public IoK8sApiCoreV1PersistentVolumeClaimVolumeSource getPersistentVolumeClaim() {
    return persistentVolumeClaim;
  }

  public void setPersistentVolumeClaim(IoK8sApiCoreV1PersistentVolumeClaimVolumeSource persistentVolumeClaim) {
    this.persistentVolumeClaim = persistentVolumeClaim;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec photonPersistentDisk(IoK8sApiCoreV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
    return this;
  }

   /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   * @return photonPersistentDisk
  **/
  @ApiModelProperty(value = "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine")
  public IoK8sApiCoreV1PhotonPersistentDiskVolumeSource getPhotonPersistentDisk() {
    return photonPersistentDisk;
  }

  public void setPhotonPersistentDisk(IoK8sApiCoreV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec portworxVolume(IoK8sApiCoreV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
    return this;
  }

   /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * @return portworxVolume
  **/
  @ApiModelProperty(value = "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine")
  public IoK8sApiCoreV1PortworxVolumeSource getPortworxVolume() {
    return portworxVolume;
  }

  public void setPortworxVolume(IoK8sApiCoreV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec projected(IoK8sApiCoreV1ProjectedVolumeSource projected) {
    this.projected = projected;
    return this;
  }

   /**
   * Items for all in one resources secrets, configmaps, and downward API
   * @return projected
  **/
  @ApiModelProperty(value = "Items for all in one resources secrets, configmaps, and downward API")
  public IoK8sApiCoreV1ProjectedVolumeSource getProjected() {
    return projected;
  }

  public void setProjected(IoK8sApiCoreV1ProjectedVolumeSource projected) {
    this.projected = projected;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec quobyte(IoK8sApiCoreV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
    return this;
  }

   /**
   * Quobyte represents a Quobyte mount on the host that shares a pod&#39;s lifetime
   * @return quobyte
  **/
  @ApiModelProperty(value = "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime")
  public IoK8sApiCoreV1QuobyteVolumeSource getQuobyte() {
    return quobyte;
  }

  public void setQuobyte(IoK8sApiCoreV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec rbd(IoK8sApiCoreV1RBDVolumeSource rbd) {
    this.rbd = rbd;
    return this;
  }

   /**
   * RBD represents a Rados Block Device mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
   * @return rbd
  **/
  @ApiModelProperty(value = "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md")
  public IoK8sApiCoreV1RBDVolumeSource getRbd() {
    return rbd;
  }

  public void setRbd(IoK8sApiCoreV1RBDVolumeSource rbd) {
    this.rbd = rbd;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec scaleIO(IoK8sApiCoreV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
    return this;
  }

   /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * @return scaleIO
  **/
  @ApiModelProperty(value = "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.")
  public IoK8sApiCoreV1ScaleIOVolumeSource getScaleIO() {
    return scaleIO;
  }

  public void setScaleIO(IoK8sApiCoreV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec secret(IoK8sApiCoreV1SecretVolumeSource secret) {
    this.secret = secret;
    return this;
  }

   /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * @return secret
  **/
  @ApiModelProperty(value = "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret")
  public IoK8sApiCoreV1SecretVolumeSource getSecret() {
    return secret;
  }

  public void setSecret(IoK8sApiCoreV1SecretVolumeSource secret) {
    this.secret = secret;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec storageos(IoK8sApiCoreV1StorageOSVolumeSource storageos) {
    this.storageos = storageos;
    return this;
  }

   /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * @return storageos
  **/
  @ApiModelProperty(value = "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.")
  public IoK8sApiCoreV1StorageOSVolumeSource getStorageos() {
    return storageos;
  }

  public void setStorageos(IoK8sApiCoreV1StorageOSVolumeSource storageos) {
    this.storageos = storageos;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec subPath(String subPath) {
    this.subPath = subPath;
    return this;
  }

   /**
   * Get subPath
   * @return subPath
  **/
  @ApiModelProperty(value = "")
  public String getSubPath() {
    return subPath;
  }

  public void setSubPath(String subPath) {
    this.subPath = subPath;
  }

  public ComGithubAppscodeStashApisStashV1alpha1LocalSpec vsphereVolume(IoK8sApiCoreV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
    return this;
  }

   /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * @return vsphereVolume
  **/
  @ApiModelProperty(value = "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine")
  public IoK8sApiCoreV1VsphereVirtualDiskVolumeSource getVsphereVolume() {
    return vsphereVolume;
  }

  public void setVsphereVolume(IoK8sApiCoreV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComGithubAppscodeStashApisStashV1alpha1LocalSpec comGithubAppscodeStashApisStashV1alpha1LocalSpec = (ComGithubAppscodeStashApisStashV1alpha1LocalSpec) o;
    return Objects.equals(this.awsElasticBlockStore, comGithubAppscodeStashApisStashV1alpha1LocalSpec.awsElasticBlockStore) &&
        Objects.equals(this.azureDisk, comGithubAppscodeStashApisStashV1alpha1LocalSpec.azureDisk) &&
        Objects.equals(this.azureFile, comGithubAppscodeStashApisStashV1alpha1LocalSpec.azureFile) &&
        Objects.equals(this.cephfs, comGithubAppscodeStashApisStashV1alpha1LocalSpec.cephfs) &&
        Objects.equals(this.cinder, comGithubAppscodeStashApisStashV1alpha1LocalSpec.cinder) &&
        Objects.equals(this.configMap, comGithubAppscodeStashApisStashV1alpha1LocalSpec.configMap) &&
        Objects.equals(this.downwardAPI, comGithubAppscodeStashApisStashV1alpha1LocalSpec.downwardAPI) &&
        Objects.equals(this.emptyDir, comGithubAppscodeStashApisStashV1alpha1LocalSpec.emptyDir) &&
        Objects.equals(this.fc, comGithubAppscodeStashApisStashV1alpha1LocalSpec.fc) &&
        Objects.equals(this.flexVolume, comGithubAppscodeStashApisStashV1alpha1LocalSpec.flexVolume) &&
        Objects.equals(this.flocker, comGithubAppscodeStashApisStashV1alpha1LocalSpec.flocker) &&
        Objects.equals(this.gcePersistentDisk, comGithubAppscodeStashApisStashV1alpha1LocalSpec.gcePersistentDisk) &&
        Objects.equals(this.gitRepo, comGithubAppscodeStashApisStashV1alpha1LocalSpec.gitRepo) &&
        Objects.equals(this.glusterfs, comGithubAppscodeStashApisStashV1alpha1LocalSpec.glusterfs) &&
        Objects.equals(this.hostPath, comGithubAppscodeStashApisStashV1alpha1LocalSpec.hostPath) &&
        Objects.equals(this.iscsi, comGithubAppscodeStashApisStashV1alpha1LocalSpec.iscsi) &&
        Objects.equals(this.mountPath, comGithubAppscodeStashApisStashV1alpha1LocalSpec.mountPath) &&
        Objects.equals(this.nfs, comGithubAppscodeStashApisStashV1alpha1LocalSpec.nfs) &&
        Objects.equals(this.persistentVolumeClaim, comGithubAppscodeStashApisStashV1alpha1LocalSpec.persistentVolumeClaim) &&
        Objects.equals(this.photonPersistentDisk, comGithubAppscodeStashApisStashV1alpha1LocalSpec.photonPersistentDisk) &&
        Objects.equals(this.portworxVolume, comGithubAppscodeStashApisStashV1alpha1LocalSpec.portworxVolume) &&
        Objects.equals(this.projected, comGithubAppscodeStashApisStashV1alpha1LocalSpec.projected) &&
        Objects.equals(this.quobyte, comGithubAppscodeStashApisStashV1alpha1LocalSpec.quobyte) &&
        Objects.equals(this.rbd, comGithubAppscodeStashApisStashV1alpha1LocalSpec.rbd) &&
        Objects.equals(this.scaleIO, comGithubAppscodeStashApisStashV1alpha1LocalSpec.scaleIO) &&
        Objects.equals(this.secret, comGithubAppscodeStashApisStashV1alpha1LocalSpec.secret) &&
        Objects.equals(this.storageos, comGithubAppscodeStashApisStashV1alpha1LocalSpec.storageos) &&
        Objects.equals(this.subPath, comGithubAppscodeStashApisStashV1alpha1LocalSpec.subPath) &&
        Objects.equals(this.vsphereVolume, comGithubAppscodeStashApisStashV1alpha1LocalSpec.vsphereVolume);
  }

  @Override
  public int hashCode() {
    return Objects.hash(awsElasticBlockStore, azureDisk, azureFile, cephfs, cinder, configMap, downwardAPI, emptyDir, fc, flexVolume, flocker, gcePersistentDisk, gitRepo, glusterfs, hostPath, iscsi, mountPath, nfs, persistentVolumeClaim, photonPersistentDisk, portworxVolume, projected, quobyte, rbd, scaleIO, secret, storageos, subPath, vsphereVolume);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComGithubAppscodeStashApisStashV1alpha1LocalSpec {\n");
    
    sb.append("    awsElasticBlockStore: ").append(toIndentedString(awsElasticBlockStore)).append("\n");
    sb.append("    azureDisk: ").append(toIndentedString(azureDisk)).append("\n");
    sb.append("    azureFile: ").append(toIndentedString(azureFile)).append("\n");
    sb.append("    cephfs: ").append(toIndentedString(cephfs)).append("\n");
    sb.append("    cinder: ").append(toIndentedString(cinder)).append("\n");
    sb.append("    configMap: ").append(toIndentedString(configMap)).append("\n");
    sb.append("    downwardAPI: ").append(toIndentedString(downwardAPI)).append("\n");
    sb.append("    emptyDir: ").append(toIndentedString(emptyDir)).append("\n");
    sb.append("    fc: ").append(toIndentedString(fc)).append("\n");
    sb.append("    flexVolume: ").append(toIndentedString(flexVolume)).append("\n");
    sb.append("    flocker: ").append(toIndentedString(flocker)).append("\n");
    sb.append("    gcePersistentDisk: ").append(toIndentedString(gcePersistentDisk)).append("\n");
    sb.append("    gitRepo: ").append(toIndentedString(gitRepo)).append("\n");
    sb.append("    glusterfs: ").append(toIndentedString(glusterfs)).append("\n");
    sb.append("    hostPath: ").append(toIndentedString(hostPath)).append("\n");
    sb.append("    iscsi: ").append(toIndentedString(iscsi)).append("\n");
    sb.append("    mountPath: ").append(toIndentedString(mountPath)).append("\n");
    sb.append("    nfs: ").append(toIndentedString(nfs)).append("\n");
    sb.append("    persistentVolumeClaim: ").append(toIndentedString(persistentVolumeClaim)).append("\n");
    sb.append("    photonPersistentDisk: ").append(toIndentedString(photonPersistentDisk)).append("\n");
    sb.append("    portworxVolume: ").append(toIndentedString(portworxVolume)).append("\n");
    sb.append("    projected: ").append(toIndentedString(projected)).append("\n");
    sb.append("    quobyte: ").append(toIndentedString(quobyte)).append("\n");
    sb.append("    rbd: ").append(toIndentedString(rbd)).append("\n");
    sb.append("    scaleIO: ").append(toIndentedString(scaleIO)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    storageos: ").append(toIndentedString(storageos)).append("\n");
    sb.append("    subPath: ").append(toIndentedString(subPath)).append("\n");
    sb.append("    vsphereVolume: ").append(toIndentedString(vsphereVolume)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

